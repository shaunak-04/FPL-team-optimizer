{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "edc8de34",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import joblib\n",
    "from pulp import LpProblem, LpVariable, lpSum, LpMaximize, LpBinary\n",
    "import numpy as np\n",
    "\n",
    "# Load models\n",
    "try:\n",
    "    gk_model = joblib.load(\"gk_model.pkl\")\n",
    "    def_model = joblib.load(\"def_model.pkl\")\n",
    "    mid_model = joblib.load(\"mid_model.pkl\")\n",
    "    fwd_model = joblib.load(\"fwd_model.pkl\")\n",
    "except FileNotFoundError as e:\n",
    "    print(f\"Error loading models: {e}\")\n",
    "\n",
    "# Load data\n",
    "try:\n",
    "    gk_df = pd.read_csv(\"fpl_gk_data.csv\")\n",
    "    def_df = pd.read_csv(\"fpl_def_data.csv\")\n",
    "    mid_df = pd.read_csv(\"fpl_mid_data.csv\")\n",
    "    fwd_df = pd.read_csv(\"fpl_fwd_data.csv\")\n",
    "except FileNotFoundError as e:\n",
    "    print(f\"Error loading data: {e}\")\n",
    "\n",
    "def predict_for_gameweek(season, gameweek):\n",
    "    \"\"\"Predict player points for NEXT gameweek using current gameweek data\"\"\"\n",
    "    def prepare(df, model):\n",
    "        current_gw_data = df[(df['season'] == season) & (df['gameweek'] == gameweek)].copy()\n",
    "        \n",
    "        if current_gw_data.empty:\n",
    "            return pd.DataFrame(columns=['name', 'team', 'value', 'predicted_next_points', 'actual_next_points'])\n",
    "        \n",
    "        ids = current_gw_data[['name', 'team', 'value']].copy()\n",
    "        \n",
    "        # Add actual future points for validation (but NOT used for prediction)\n",
    "        if 'future_points' in current_gw_data.columns:\n",
    "            ids['actual_next_points'] = current_gw_data['future_points']\n",
    "        \n",
    "        # Get training features (excluding future_points to prevent data leakage)\n",
    "        train_columns = [col for col in model.feature_names_in_ if col != 'future_points']\n",
    "        \n",
    "        missing_cols = set(train_columns) - set(current_gw_data.columns)\n",
    "        if missing_cols:\n",
    "            print(f\"Missing columns: {missing_cols}\")\n",
    "            return pd.DataFrame(columns=['name', 'team', 'value', 'predicted_next_points', 'actual_next_points'])\n",
    "        \n",
    "        X = current_gw_data[train_columns].fillna(0)\n",
    "        preds = model.predict(X)\n",
    "        \n",
    "        result = ids.copy()\n",
    "        result['predicted_next_points'] = preds\n",
    "        result['value'] = result['value'] / 10\n",
    "        \n",
    "        # Clean data\n",
    "        result['predicted_next_points'] = pd.to_numeric(result['predicted_next_points'], errors='coerce').fillna(0)\n",
    "        result['value'] = pd.to_numeric(result['value'], errors='coerce').fillna(4.0)\n",
    "        \n",
    "        if 'actual_next_points' in result.columns:\n",
    "            result['actual_next_points'] = pd.to_numeric(result['actual_next_points'], errors='coerce').fillna(0)\n",
    "        \n",
    "        result = result[np.isfinite(result['predicted_next_points']) & np.isfinite(result['value'])]\n",
    "        return result.reset_index(drop=True)\n",
    "    \n",
    "    return (prepare(gk_df, gk_model), prepare(def_df, def_model), \n",
    "            prepare(mid_df, mid_model), prepare(fwd_df, fwd_model))\n",
    "\n",
    "def optimize_fpl_team(gk, defs, mids, fwds, budget=100.0, formation='3-5-2'):\n",
    "    \"\"\"Optimize FPL team selection\"\"\"\n",
    "    if any(df.empty for df in [gk, defs, mids, fwds]):\n",
    "        return pd.DataFrame(), None, None\n",
    "    \n",
    "    all_players = pd.concat([\n",
    "        gk.assign(position='GK'), defs.assign(position='DEF'),\n",
    "        mids.assign(position='MID'), fwds.assign(position='FWD')\n",
    "    ], ignore_index=True)\n",
    "    \n",
    "    # Parse formation\n",
    "    def_start, mid_start, fwd_start = map(int, formation.split('-'))\n",
    "    \n",
    "    # Create optimization problem\n",
    "    prob = LpProblem(\"FPL_Squad_Optimization\", LpMaximize)\n",
    "    n_players = len(all_players)\n",
    "    \n",
    "    # Decision variables\n",
    "    squad_vars = [LpVariable(f\"squad_{i}\", cat=LpBinary) for i in range(n_players)]\n",
    "    start_vars = [LpVariable(f\"start_{i}\", cat=LpBinary) for i in range(n_players)]\n",
    "    captain_vars = [LpVariable(f\"captain_{i}\", cat=LpBinary) for i in range(n_players)]\n",
    "    vice_vars = [LpVariable(f\"vice_{i}\", cat=LpBinary) for i in range(n_players)]\n",
    "    \n",
    "    # Objective: maximize predicted points including captain bonus\n",
    "    prob += lpSum([\n",
    "        start_vars[i] * float(all_players.iloc[i]['predicted_next_points']) +\n",
    "        captain_vars[i] * float(all_players.iloc[i]['predicted_next_points'])\n",
    "        for i in range(n_players)\n",
    "    ])\n",
    "    \n",
    "    # Constraints\n",
    "    prob += lpSum([squad_vars[i] * float(all_players.iloc[i]['value']) for i in range(n_players)]) <= budget\n",
    "    prob += lpSum(squad_vars) == 15\n",
    "    prob += lpSum(start_vars) == 11\n",
    "    prob += lpSum(captain_vars) == 1\n",
    "    prob += lpSum(vice_vars) == 1\n",
    "    \n",
    "    # Link constraints\n",
    "    for i in range(n_players):\n",
    "        prob += start_vars[i] <= squad_vars[i]\n",
    "        prob += captain_vars[i] <= start_vars[i]\n",
    "        prob += vice_vars[i] <= start_vars[i]\n",
    "        prob += captain_vars[i] + vice_vars[i] <= 1\n",
    "    \n",
    "    # Position constraints\n",
    "    gk_indices = [i for i in range(n_players) if all_players.iloc[i]['position'] == 'GK']\n",
    "    def_indices = [i for i in range(n_players) if all_players.iloc[i]['position'] == 'DEF']\n",
    "    mid_indices = [i for i in range(n_players) if all_players.iloc[i]['position'] == 'MID']\n",
    "    fwd_indices = [i for i in range(n_players) if all_players.iloc[i]['position'] == 'FWD']\n",
    "    \n",
    "    prob += lpSum([squad_vars[i] for i in gk_indices]) == 2\n",
    "    prob += lpSum([squad_vars[i] for i in def_indices]) == 5\n",
    "    prob += lpSum([squad_vars[i] for i in mid_indices]) == 5\n",
    "    prob += lpSum([squad_vars[i] for i in fwd_indices]) == 3\n",
    "    \n",
    "    prob += lpSum([start_vars[i] for i in gk_indices]) == 1\n",
    "    prob += lpSum([start_vars[i] for i in def_indices]) == def_start\n",
    "    prob += lpSum([start_vars[i] for i in mid_indices]) == mid_start\n",
    "    prob += lpSum([start_vars[i] for i in fwd_indices]) == fwd_start\n",
    "    \n",
    "    # Max 3 players per team\n",
    "    for team in all_players['team'].unique():\n",
    "        team_indices = [i for i in range(n_players) if all_players.iloc[i]['team'] == team]\n",
    "        prob += lpSum([squad_vars[i] for i in team_indices]) <= 3\n",
    "    \n",
    "    prob.solve()\n",
    "    \n",
    "    if prob.status != 1:\n",
    "        return pd.DataFrame(), None, None\n",
    "    \n",
    "    # Extract results\n",
    "    squad_indices = [i for i in range(n_players) if squad_vars[i].value() == 1]\n",
    "    start_indices = [i for i in range(n_players) if start_vars[i].value() == 1]\n",
    "    captain_index = [i for i in range(n_players) if captain_vars[i].value() == 1][0]\n",
    "    vice_index = [i for i in range(n_players) if vice_vars[i].value() == 1][0]\n",
    "    \n",
    "    squad_df = all_players.iloc[squad_indices].copy()\n",
    "    squad_df['in_starting_xi'] = squad_df.index.isin(start_indices)\n",
    "    squad_df['is_captain'] = squad_df.index == captain_index\n",
    "    squad_df['is_vice_captain'] = squad_df.index == vice_index\n",
    "    \n",
    "    squad_df['effective_predicted_points'] = squad_df['predicted_next_points'].copy()\n",
    "    squad_df.loc[squad_df['is_captain'], 'effective_predicted_points'] *= 2\n",
    "    \n",
    "    # Add actual points if available\n",
    "    if 'actual_next_points' in squad_df.columns:\n",
    "        squad_df['effective_actual_points'] = squad_df['actual_next_points'].copy()\n",
    "        squad_df.loc[squad_df['is_captain'], 'effective_actual_points'] *= 2\n",
    "    \n",
    "    squad_df = squad_df.sort_values(['in_starting_xi', 'position', 'predicted_next_points'], \n",
    "                                   ascending=[False, True, False]).reset_index(drop=True)\n",
    "    \n",
    "    return squad_df, all_players.iloc[captain_index], all_players.iloc[vice_index]\n",
    "\n",
    "def get_actual_best_team(season, target_gameweek, budget=100.0, formation='3-5-2'):\n",
    "    \"\"\"Get actual best team using total_points from target gameweek\"\"\"\n",
    "    def get_actual_data(df):\n",
    "        target_gw_data = df[(df['season'] == season) & (df['gameweek'] == target_gameweek)].copy()\n",
    "        if target_gw_data.empty:\n",
    "            return pd.DataFrame(columns=['name', 'team', 'value', 'actual_points'])\n",
    "        \n",
    "        result = target_gw_data[['name', 'team', 'value', 'total_points']].copy()\n",
    "        result.rename(columns={'total_points': 'actual_points'}, inplace=True)\n",
    "        result['value'] = result['value'] / 10\n",
    "        \n",
    "        result['actual_points'] = pd.to_numeric(result['actual_points'], errors='coerce').fillna(0)\n",
    "        result['value'] = pd.to_numeric(result['value'], errors='coerce').fillna(4.0)\n",
    "        \n",
    "        return result[np.isfinite(result['actual_points']) & np.isfinite(result['value'])].reset_index(drop=True)\n",
    "    \n",
    "    # Get actual data\n",
    "    actual_gk = get_actual_data(gk_df).assign(position='GK')\n",
    "    actual_def = get_actual_data(def_df).assign(position='DEF')\n",
    "    actual_mid = get_actual_data(mid_df).assign(position='MID')\n",
    "    actual_fwd = get_actual_data(fwd_df).assign(position='FWD')\n",
    "    \n",
    "    all_actual = pd.concat([actual_gk, actual_def, actual_mid, actual_fwd], ignore_index=True)\n",
    "    if all_actual.empty:\n",
    "        return pd.DataFrame(), None, None\n",
    "    \n",
    "    # Same optimization logic but using actual_points\n",
    "    def_start, mid_start, fwd_start = map(int, formation.split('-'))\n",
    "    \n",
    "    prob = LpProblem(\"Actual_Best_Team\", LpMaximize)\n",
    "    n_players = len(all_actual)\n",
    "    \n",
    "    squad_vars = [LpVariable(f\"actual_squad_{i}\", cat=LpBinary) for i in range(n_players)]\n",
    "    start_vars = [LpVariable(f\"actual_start_{i}\", cat=LpBinary) for i in range(n_players)]\n",
    "    captain_vars = [LpVariable(f\"actual_captain_{i}\", cat=LpBinary) for i in range(n_players)]\n",
    "    vice_vars = [LpVariable(f\"actual_vice_{i}\", cat=LpBinary) for i in range(n_players)]\n",
    "    \n",
    "    # Objective: maximize actual points\n",
    "    prob += lpSum([\n",
    "        start_vars[i] * float(all_actual.iloc[i]['actual_points']) +\n",
    "        captain_vars[i] * float(all_actual.iloc[i]['actual_points'])\n",
    "        for i in range(n_players)\n",
    "    ])\n",
    "    \n",
    "    # Same constraints as predicted team\n",
    "    prob += lpSum([squad_vars[i] * float(all_actual.iloc[i]['value']) for i in range(n_players)]) <= budget\n",
    "    prob += lpSum(squad_vars) == 15\n",
    "    prob += lpSum(start_vars) == 11\n",
    "    prob += lpSum(captain_vars) == 1\n",
    "    prob += lpSum(vice_vars) == 1\n",
    "    \n",
    "    for i in range(n_players):\n",
    "        prob += start_vars[i] <= squad_vars[i]\n",
    "        prob += captain_vars[i] <= start_vars[i]\n",
    "        prob += vice_vars[i] <= start_vars[i]\n",
    "        prob += captain_vars[i] + vice_vars[i] <= 1\n",
    "    \n",
    "    # Position constraints\n",
    "    gk_indices = [i for i in range(n_players) if all_actual.iloc[i]['position'] == 'GK']\n",
    "    def_indices = [i for i in range(n_players) if all_actual.iloc[i]['position'] == 'DEF']\n",
    "    mid_indices = [i for i in range(n_players) if all_actual.iloc[i]['position'] == 'MID']\n",
    "    fwd_indices = [i for i in range(n_players) if all_actual.iloc[i]['position'] == 'FWD']\n",
    "    \n",
    "    prob += lpSum([squad_vars[i] for i in gk_indices]) == 2\n",
    "    prob += lpSum([squad_vars[i] for i in def_indices]) == 5\n",
    "    prob += lpSum([squad_vars[i] for i in mid_indices]) == 5\n",
    "    prob += lpSum([squad_vars[i] for i in fwd_indices]) == 3\n",
    "    \n",
    "    prob += lpSum([start_vars[i] for i in gk_indices]) == 1\n",
    "    prob += lpSum([start_vars[i] for i in def_indices]) == def_start\n",
    "    prob += lpSum([start_vars[i] for i in mid_indices]) == mid_start\n",
    "    prob += lpSum([start_vars[i] for i in fwd_indices]) == fwd_start\n",
    "    \n",
    "    for team in all_actual['team'].unique():\n",
    "        team_indices = [i for i in range(n_players) if all_actual.iloc[i]['team'] == team]\n",
    "        prob += lpSum([squad_vars[i] for i in team_indices]) <= 3\n",
    "    \n",
    "    prob.solve()\n",
    "    \n",
    "    if prob.status != 1:\n",
    "        return pd.DataFrame(), None, None\n",
    "    \n",
    "    # Extract results\n",
    "    squad_indices = [i for i in range(n_players) if squad_vars[i].value() == 1]\n",
    "    start_indices = [i for i in range(n_players) if start_vars[i].value() == 1]\n",
    "    captain_index = [i for i in range(n_players) if captain_vars[i].value() == 1][0]\n",
    "    vice_index = [i for i in range(n_players) if vice_vars[i].value() == 1][0]\n",
    "    \n",
    "    actual_squad = all_actual.iloc[squad_indices].copy()\n",
    "    actual_squad['in_starting_xi'] = actual_squad.index.isin(start_indices)\n",
    "    actual_squad['is_captain'] = actual_squad.index == captain_index\n",
    "    actual_squad['is_vice_captain'] = actual_squad.index == vice_index\n",
    "    \n",
    "    actual_squad['effective_actual_points'] = actual_squad['actual_points'].copy()\n",
    "    actual_squad.loc[actual_squad['is_captain'], 'effective_actual_points'] *= 2\n",
    "    \n",
    "    actual_squad = actual_squad.sort_values(['in_starting_xi', 'position', 'actual_points'], \n",
    "                                          ascending=[False, True, False]).reset_index(drop=True)\n",
    "    \n",
    "    return actual_squad, all_actual.iloc[captain_index], all_actual.iloc[vice_index]\n",
    "\n",
    "def print_fpl_team_summary(squad_df, captain_info, vice_info, team_type=\"PREDICTED\"):\n",
    "    \"\"\"Print FPL team summary with both predicted and actual points\"\"\"\n",
    "    if squad_df.empty:\n",
    "        return\n",
    "    \n",
    "    print(f\"\\n{'='*60}\")\n",
    "    print(f\"ðŸ† {team_type} FPL TEAM\")\n",
    "    print(f\"{'='*60}\")\n",
    "    \n",
    "    starting_xi = squad_df[squad_df['in_starting_xi']]\n",
    "    bench = squad_df[~squad_df['in_starting_xi']]\n",
    "    \n",
    "    print(f\"\\nðŸ“‹ STARTING XI:\")\n",
    "    print(\"-\" * 40)\n",
    "    \n",
    "    for pos in ['GK', 'DEF', 'MID', 'FWD']:\n",
    "        pos_players = starting_xi[starting_xi['position'] == pos]\n",
    "        if not pos_players.empty:\n",
    "            print(f\"\\n{pos}:\")\n",
    "            for _, player in pos_players.iterrows():\n",
    "                captain_status = \" (C)\" if player['is_captain'] else \" (VC)\" if player['is_vice_captain'] else \"\"\n",
    "                print(f\"  {player['name']} ({player['team']}){captain_status}\")\n",
    "                \n",
    "                # Show both predicted and actual points if available\n",
    "                if team_type == \"PREDICTED\" and 'actual_next_points' in player:\n",
    "                    print(f\"    Â£{player['value']:.1f}m - Pred: {player['predicted_next_points']:.1f}, Actual: {player['actual_next_points']:.1f}\")\n",
    "                elif team_type == \"ACTUAL BEST\" and 'actual_points' in player:\n",
    "                    print(f\"    Â£{player['value']:.1f}m - Actual: {player['actual_points']:.1f}\")\n",
    "                else:\n",
    "                    points_key = 'predicted_next_points' if 'predicted_next_points' in player else 'actual_points'\n",
    "                    print(f\"    Â£{player['value']:.1f}m - {player[points_key]:.1f} pts\")\n",
    "    \n",
    "    print(f\"\\nðŸª‘ BENCH:\")\n",
    "    for i, (_, player) in enumerate(bench.iterrows(), 1):\n",
    "        points_key = 'predicted_next_points' if 'predicted_next_points' in player else 'actual_points'\n",
    "        print(f\"  {i}. {player['name']} ({player['team']}) - Â£{player['value']:.1f}m, {player[points_key]:.1f} pts\")\n",
    "    \n",
    "    # Calculate totals\n",
    "    total_cost = squad_df['value'].sum()\n",
    "    \n",
    "    if team_type == \"PREDICTED\":\n",
    "        if 'effective_actual_points' in starting_xi.columns:\n",
    "            pred_points = starting_xi['effective_predicted_points'].sum()\n",
    "            actual_points = starting_xi['effective_actual_points'].sum()\n",
    "            print(f\"\\nðŸ’° COST: Â£{total_cost:.1f}m\")\n",
    "            print(f\"ðŸ”® PREDICTED POINTS: {pred_points:.1f}\")\n",
    "            print(f\"âš¡ ACTUAL POINTS: {actual_points:.1f}\")\n",
    "            print(f\"ðŸ“Š ACCURACY: {actual_points/pred_points*100:.1f}%\")\n",
    "        else:\n",
    "            pred_points = starting_xi['effective_predicted_points'].sum()\n",
    "            print(f\"\\nðŸ’° COST: Â£{total_cost:.1f}m\")\n",
    "            print(f\"ðŸ”® PREDICTED POINTS: {pred_points:.1f}\")\n",
    "    else:\n",
    "        actual_points = starting_xi['effective_actual_points'].sum()\n",
    "        print(f\"\\nðŸ’° COST: Â£{total_cost:.1f}m\")\n",
    "        print(f\"âš¡ ACTUAL POINTS: {actual_points:.1f}\")\n",
    "    \n",
    "    print(f\"ðŸ‘‘ CAPTAIN: {captain_info['name']} ({captain_info['team']})\")\n",
    "    print(f\"ðŸ¥ˆ VICE: {vice_info['name']} ({vice_info['team']})\")\n",
    "\n",
    "def validate_fpl_team(squad_df):\n",
    "    \"\"\"Validate FPL team rules\"\"\"\n",
    "    print(f\"\\nðŸ” VALIDATING TEAM...\")\n",
    "    \n",
    "    checks = [\n",
    "        (len(squad_df) == 15, f\"Squad size: {len(squad_df)}/15\"),\n",
    "        (squad_df['position'].value_counts().get('GK', 0) == 2, \"GK: 2\"),\n",
    "        (squad_df['position'].value_counts().get('DEF', 0) == 5, \"DEF: 5\"),\n",
    "        (squad_df['position'].value_counts().get('MID', 0) == 5, \"MID: 5\"),\n",
    "        (squad_df['position'].value_counts().get('FWD', 0) == 3, \"FWD: 3\"),\n",
    "        (len(squad_df[squad_df['in_starting_xi']]) == 11, \"Starting XI: 11\"),\n",
    "        (squad_df['is_captain'].sum() == 1, \"Captain: 1\"),\n",
    "        (squad_df['is_vice_captain'].sum() == 1, \"Vice: 1\"),\n",
    "        (squad_df['team'].value_counts().max() <= 3, \"Max per team: â‰¤3\")\n",
    "    ]\n",
    "    \n",
    "    for check, desc in checks:\n",
    "        print(f\"{'âœ…' if check else 'âŒ'} {desc}\")\n",
    "    \n",
    "    return all(check for check, _ in checks)\n",
    "\n",
    "def compare_teams(predicted_squad, actual_squad, target_gameweek):\n",
    "    \"\"\"Compare predicted vs actual best team\"\"\"\n",
    "    if predicted_squad.empty or actual_squad.empty:\n",
    "        return\n",
    "    \n",
    "    print(f\"\\nðŸ“Š COMPARISON FOR GW {target_gameweek}\")\n",
    "    print(\"=\"*50)\n",
    "    \n",
    "    pred_starting = predicted_squad[predicted_squad['in_starting_xi']]\n",
    "    actual_starting = actual_squad[actual_squad['in_starting_xi']]\n",
    "    \n",
    "    if 'effective_actual_points' in pred_starting.columns:\n",
    "        pred_actual_points = pred_starting['effective_actual_points'].sum()\n",
    "        best_points = actual_starting['effective_actual_points'].sum()\n",
    "        \n",
    "        print(f\"ðŸ”® Predicted team actual score: {pred_actual_points:.1f}\")\n",
    "        print(f\"ðŸŽ¯ Best possible score: {best_points:.1f}\")\n",
    "        print(f\"ðŸ“ˆ Efficiency: {pred_actual_points/best_points*100:.1f}%\")\n",
    "        \n",
    "        # Common players\n",
    "        pred_players = set(pred_starting['name'])\n",
    "        actual_players = set(actual_starting['name'])\n",
    "        common = pred_players.intersection(actual_players)\n",
    "        \n",
    "        print(f\"ðŸ‘¥ Common players: {len(common)}/11\")\n",
    "        if common:\n",
    "            print(f\"   {', '.join(sorted(common))}\")\n",
    "\n",
    "# Main execution\n",
    "if __name__ == \"__main__\":\n",
    "    try:\n",
    "        season = \"2024-25\"\n",
    "        current_gameweek = 7\n",
    "        target_gameweek = 8\n",
    "        budget = 100.0\n",
    "        formation = \"3-5-2\"\n",
    "        \n",
    "        print(f\"ðŸŽ® FPL OPTIMIZER - Season {season}\")\n",
    "        print(f\"Using GW {current_gameweek} â†’ Predicting GW {target_gameweek}\")\n",
    "        \n",
    "        # Get predictions\n",
    "        gk_p, def_p, mid_p, fwd_p = predict_for_gameweek(season, current_gameweek)\n",
    "        \n",
    "        # Optimize teams\n",
    "        predicted_squad, pred_captain, pred_vice = optimize_fpl_team(\n",
    "            gk_p, def_p, mid_p, fwd_p, budget, formation)\n",
    "        \n",
    "        actual_squad, actual_captain, actual_vice = get_actual_best_team(\n",
    "            season, target_gameweek, budget, formation)\n",
    "        \n",
    "        # Display results\n",
    "        if not predicted_squad.empty:\n",
    "            print_fpl_team_summary(predicted_squad, pred_captain, pred_vice, \"PREDICTED\")\n",
    "            validate_fpl_team(predicted_squad)\n",
    "        \n",
    "        if not actual_squad.empty:\n",
    "            print_fpl_team_summary(actual_squad, actual_captain, actual_vice, \"ACTUAL BEST\")\n",
    "            validate_fpl_team(actual_squad)\n",
    "        \n",
    "        # Compare teams\n",
    "        compare_teams(predicted_squad, actual_squad, target_gameweek)\n",
    "        \n",
    "        # Export results\n",
    "        if not predicted_squad.empty:\n",
    "            predicted_squad.to_csv(f\"predicted_team_gw{target_gameweek}.csv\", index=False)\n",
    "        if not actual_squad.empty:\n",
    "            actual_squad.to_csv(f\"actual_best_team_gw{target_gameweek}.csv\", index=False)\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"Error: {e}\")\n",
    "        import traceback\n",
    "        traceback.print_exc()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
